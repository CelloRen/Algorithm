1.旋转字符串：
将abcdefg变为defgabc（即将前面n位字符移到后面）
idea:
   实现一个反转算法F
   F(abc) --> cba
   F(defg)--> gfed
   则此时cbagfed
   再反转：
   F(cbagfde)-->defgabc
2.字符串包含
比如：ABCD 包含 BAD（顺序无关）
      ABCD不包含BCE
      ABCD 包含 AAA（可重复）
idea:
   HashMap空间换时间,将ABCD(源串每个字符存入)，如果目标字符串任意一个字符不在Map中，则不包含
   Count,用一个int[26]的数组统计源串出现过哪些字符a-z
3.字符串转化为整数
idea:
（1）判空
（2）去空格
（3）正负
（4）溢出
（5）非法字符跳出
4.回文字串判断
idea:
由中间向两边拓展
5.最长回文字串
idea:
（1）拓展法：对每一个字符尽可能的拓展，记录最大的
（2）Manacher：这个是基于镜像的，比如abccbadabccba...中d的右边其实是和左边一样的，有的工作就没必要做，
               因为左右基于d对称，只有右边继续扩展，也就是...中可能会有变化。
               算法时间复杂度O（n），有兴趣可以看看相应博客。
6.给出字符串，求全排列
idea:
（1）递归
（2）字典序
     这个很有意思比如 134521 的下一个比它大的数是：135124

next_permutation算法思想（升序：相邻两个位置ai < ai+1，ai 称作该升序的首位）
步骤（二找、一交换、一翻转）
 找到排列中最后（最右）一个升序的首位位置i，x = ai （4）
 找到排列中第i位右边最后一个比ai 大的位置j，y = aj （5）
 交换x，y（135421）
 把第(i+ 1)位到最后的部分翻转（135124）

