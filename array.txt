1.寻找最小的k个数：
idea:
   （1）构建二叉树（有点麻烦）
   （2）先排序（时间复杂度有点高）
   （3）快排的partition的思想：
        根据一个哨兵位将数组分为两部分，左边n个数，右边m个数
        如果n<k，则再在右边找最小的k-n个数
        如果n>k, 则在左边找最小的k个数
        如果n=k，找到

2.寻找和为定值的两个数
idea:
   Hashmap

3.寻找和为定值的多个数
idea:
   递归（取不取第N个数）
        if(取) 问题变为寻找前n-1个数使和为sum-num[n]

4.最大连续子数组和
idea:
  从左向右遍历数组num[]，对于num[i]有两种选择
  if(currSum+num[i]<num[i])
    num[i]成为新的子数组的第一个元素
  else
    子数组加入num[i]
  每次if(currSum>sumMax) 则更新。

5.跳台阶
idea:
  动态规划
  初始：dp[0]=dp[1]=1;
  递推：dp[n]=dp[n-1]+dp[n-2]

6.奇偶排序
将奇数和偶数分开，奇数在前，偶数在后
idea:
  其实这是一类问题，根据某一个条件将数组分为两类
  维护两个指针即可，一左一右，左边找偶数，右边找奇数，交换。直到指针相遇。
  其次，如果要保证相对顺序的话。
  还是维护两个指针。一个指针A找从左到右第一个偶数，第二个指针B在指针A右边找第一个出现的奇数，交换。直到指针B到头。

7.三色球排序
0-红，1-黄，2-绿，将数组分为三部分，分别是红黄绿
idea:
  维护三个指针，left,curr,right
  move curr from head to tail:
    if(a[curr]==0){
      swap(a[left],a[curr]);
      curr++;
      left++; 
    }
    if(a[cuur]==1){
      curr++;
    }
    if(a[cuur]==2){
      swap(a[curr],a[right]);
      right--;
    }

8.有序数组的查找
idea:
   二分查找以及变种

9.行列递增矩阵查找
idea：
   从右上角往左下，查找

10.找数组出现次数超过一半的数：
idea:
（1）HashMap
（2）每次去除两个不相等的数，最后剩的就是结果
（3）用一个count记录，候选者连续出现的就+1，下次没出现就减1，如果为0，下一个是新的候选者。遍历完成后的候选者为结果。
  
  
